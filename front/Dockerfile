# Dockerfile_пример_для_фронта_c_описанием поддерживает следующие инструкции:

# 1. ADD - Добавьте локальные или удаленные файлы и каталоги.
# 2. ARG - 	Используйте переменные времени сборки.
# 3. CMD - Укажите команды по умолчанию.
# 4. COPY - Копировать файлы и каталоги.
# 5. ENTRYPOINT - Укажите исполняемый файл по умолчанию.
# 6. ENV - Установите переменные среды.
# 7. EXPOSE - Опишите, какие порты прослушивает ваше приложение.
# 8. FROM - Создайте новый этап сборки из базового образа.
# 9. HEALTHCHECK - Проверка работоспособности контейнера при запуске.
# 10. LABEL - Добавьте метаданные к изображению.
# 11. MAINTAINER - Укажите автора изображения.
# 12. ONBUILD - Укажите инструкции относительно того, когда изображение будет использоваться в сборке.
# 13. RUN - Выполнение команд сборки.
# 14. SHELL - Установить оболочку изображения по умолчанию.
# 15. STOPSIGNAL - Укажите системный вызов сигнала для выхода из контейнера.
# 16. USER - Установите идентификатор пользователя и группы.
# 17. VOLUME - Создание монтирований томов
# 18. WORKDIR - Изменить рабочий каталог.

# ==========================================================================================
# Описание команд:

# 1. ADD [OPTIONS] <src> ... <dest>
#    OPTIONS:
#     1.1 --keep-git-dir
#     1.2 --checksum
#     1.3 --chown
#     1.4 --chmod
#     1.5 --link
#     1.6 --exclude
#
#       Инструкция ADD копирует новые файлы или каталоги из <src>и добавляет их в файловую систему образа
#       по пути <dest>. Файлы и каталоги можно копировать из
#       1.контекста сборки, 2.удаленного URL или 3.репозитория Git.

#       Инструкции ADD и COPY функционально похожи, но служат немного разным целям

# 2. ARG <name>[=<default value>] [<name>[=<default value>]...]

#     Инструкция ARGопределяет переменную, которую пользователи могут передавать во время
#     сборки сборщику с помощью docker buildкоманды, использующей --build-arg <varname>=<value> флаг.
#     Dockerfile_пример_для_фронта_c_описанием может включать одну или несколько ARG инструкций.


# 3. CMD - Инструкция CMD задает команду, которая будет выполнена при запуске контейнера из образа.
#
#        Три формы указать CMD:

#        CMD ["executable","param1","param2"] (исполнительная форма)
#        CMD ["param1","param2"] (форма exec, в качестве параметров по умолчанию ENTRYPOINT)
#        CMD command param1 param2 (форма оболочки)
#
#        В Dockerfile_пример_для_фронта_c_описанием может быть только одна CMD инструкция.
#        Если вы перечислите более одной CMD, то вступит в силу только последняя.
#
#        Целью a CMD является предоставление значений по умолчанию для исполняемого контейнера.
#        Эти значения по умолчанию могут включать исполняемый файл или могут не включать исполняемый файл,
#        в этом случае необходимо ENTRYPOINT также указать инструкцию.

#  4. COPY [OPTIONS] <src> ... <dest>
#     OPTIONS:
#      4.1 --from=<image|stage|context>
#      4.2 --chown
#      4.3 --chmod
#      4.4 --link
#      4.5 --parents
#      4.6 --exclude
#
#      Инструкция COPY копирует новые файлы или каталоги из <src> и добавляет их в файловую систему
#      образа по пути <dest>. Файлы и каталоги могут быть скопированы из 1.контекста сборки, 2.этапа сборки,
#      3.именованного контекста или 4. образа.


#  6. ENV <key>=<value> [<key>=<value>...]
#     Инструкция ENVустанавливает переменную окружения <key>в значение <value>.
#     Это значение будет в окружении для всех последующих инструкций на этапе сборки и
#     может быть заменено встроенным во многих. Значение будет интерпретировано для других переменных окружения,
#     поэтому символы кавычек будут удалены, если они не экранированы.


#  7. EXPOSE <port> [<port>/<protocol>...]
#      Инструкция EXPOSE сообщает Docker, что контейнер прослушивает указанные сетевые порты во время выполнения.
#      Вы можете указать, прослушивает ли порт TCP или UDP, и по умолчанию используется TCP,
#      если вы не укажете протокол.

#       Инструкция EXPOSEна самом деле не публикует порт. Она функционирует как своего рода документация
#       между тем, кто создает образ, и тем, кто запускает контейнер,
#       о том, какие порты должны быть опубликованы.

#        EXPOSE 80/tcp
#        EXPOSE 80/udp

# (Начало докер-файла, перед ним может стоят только ARG)
# 8. FROM [--platform=<platform>] <image>[:<tag> | @<digest>] [AS <name>]
    # 8.1  --platform - флаг может использоваться для указания платформы образа в случае FROM
#    ссылки на многоплатформенный образ. Например, linux/amd64, linux/arm64или windows/amd64.
#    По умолчанию используется целевая платформа запроса сборки. Глобальные аргументы сборки
#    могут использоваться в значении этого флага, например, автоматические ARG платформы позволяют
#    принудительно перевести этап на собственную платформу сборки ( --platform=$BUILDPLATFORM)
#    и использовать ее для кросс-компиляции на целевую платформу внутри этапа.
    # 8.2 [:<tag> | @<digest>] - Значения tagor digestнеобязательны. Если вы пропустите любой из них,
#          конструктор latestпо умолчанию применит тег. Конструктор возвращает ошибку, если не может
#          найти tagзначение.
    # 8.3 [AS <name>] - При желании можно дать имя новому этапу сборки, добавив его AS nameк FROMинструкции.
#          Имя можно использовать в последующих инструкциях FROM <name>, COPY --from=<name>,
#          и RUN --mount=type=bind,from=<name>для ссылки на образ, созданный на этом этапе.

#    Описание:
#    FROM может появляться несколько раз в одном Dockerfile_пример_для_фронта_c_описанием для создания нескольких образов или
#    использования одного этапа сборки в качестве зависимости для другого. Просто запишите
#    последний идентификатор образа, выведенный коммитом перед каждой новой FROM инструкцией.
#    Каждая FROM инструкция очищает любое состояние, созданное предыдущими инструкциями.


#  13. RUN [OPTIONS] <command> ... - shell форма
#      RUN [OPTIONS] [ "<command>", ... ] - exec форма
#
#      Инструкция RUN выполнит любые команды для создания нового слоя поверх текущего образа.
#      Добавленный слой используется на следующем шаге в Dockerfile_пример_для_фронта_c_описанием.

#  15. STOPSIGNAL signal
#       Инструкция STOPSIGNALустанавливает системный сигнал вызова, который будет отправлен контейнеру для выхода.
#       Этот сигнал может быть именем сигнала в формате SIG<NAME>, например SIGKILL, или беззнаковым числом,
#       соответствующим позиции в таблице системных вызовов ядра, например 9. Значение по умолчанию — SIGTERM если не определено.
#
#       Стоп-сигнал изображения по умолчанию можно переопределить для каждого контейнера с помощью --stop-signalфлага docker
#       runи docker create.


#  17. VOLUME ["/data"]
#       Инструкция VOLUME создает точку монтирования с указанным именем и помечает ее как
#       содержащую внешние смонтированные тома из собственного хоста или других контейнеров.
#       Значение может быть массивом JSON, VOLUME ["/var/log/"] или простой строкой с несколькими аргументами,
#       например VOLUME /var/log или VOLUME /var/log /var/db

#  18. WORKDIR /path/to/workdir
#      Инструкция WORKDIR устанавливает рабочий каталог для любых инструкций RUN, CMD, и ENTRYPOINT,
#      которые следуют за ней в Dockerfile_пример_для_фронта_c_описанием. Если не существует, он будет создан,
#      даже если он не используется ни в одной последующей инструкции Dockerfile_пример_для_фронта_c_описанием.COPY ADD WORKDIR


ARG TEST_ARG=test
FROM node:16
WORKDIR /app
COPY . .
RUN ["npm", "install"]
RUN ["npm", "run", "build"]

# Здесь нельзя монтировать тома с внешним контекстом хоста (файловой системой хоста)
# он только создает тома внутри контейнера, связывая их с томами хоста (расположеных в папке докер, вне текущего проекта)
# эти тома имеют в имени длинные id (называются анонимные тома) и не удобны в использовании
#
# Для монтирования с локальным контекстом хоста нужно использовать cli (-v, --volume)

# docker run -v $pwd/volume:/volume IMAGE
# docker run -v ./volume:/volume IMAGE

#VOLUME vol1 vol2 (в Dockerfile_пример_для_фронта_c_описанием) - создаст тома Type: 'volume'
#   при docker container inspect CONTAINER будет раздел:
#
#    "Volumes": {
#                   "vol1": {},
#                   "vol2": {}
#               }

#    "Mounts": [{
#          "Type": "volume",
#          "Name": "cc06db4093fb200bbd5df907671af13e2bd4ed0bada313443d19c64c7b28ca91",
#          "Source": "/var/lib/docker/volumes/cc06db4093fb200bbd5df907671af13e2bd4ed0bada313443d19c64c7b28ca91/_data",
#          "Destination": "vol1",
#          "Driver": "local",
#           "Mode": "",
#           "RW": true, - разрешить запись\чтение в том (:ro (readonly) в конце -v | --volume поставит флаг на false)
#           "Propagation": ""
#          }]

# VOLUME vol1 vol2
EXPOSE 3000
CMD ["npm", "run", "start"]